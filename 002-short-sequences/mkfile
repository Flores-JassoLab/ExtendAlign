MKSHELL=/bin/bash

< config.mk
#Añadiendo aquellas secuencias que no alinearon en blastn
results/%.final_mismatch.txt:	results/%.extended_mismatches.debug1.txt
	set -x
	mkdir -p `dirname "$target"`
	{
	echo "#1_bta	2_bta-length	3_pre-hsa	4_pident	5_length	6_mismatch	7_gapopen	8_qstart	9_qend	10_sstart	11_send	12_evalue	13_bitscore	14_QUERYLENGTH	15_SUBJECTLENGTH	16_QUERY5SEQ	17_QUERY3SEQ	18_SUBJECT5SEQ	19_SUBJECT3SEQ	20_COMPLETEQUERYSEQ	21_COMPLETESUBJECTSEQ	22_EXTENDEDMISMATCH	#23_TOTALMISMATCH" | tr '[:upper:]' '[:lower:]'
	join \
		-a 1 \
			<(awk '$0 ~ /^>/ {name=$0; next}; $0 !~ /^>/ {print name "\t" length($0)}' \
			$QUERYFASTA \
			| sort \
			| sed 's/^>//g' \
			| sed -e '1i\#1_bta\t2_bta-length') \
			<(sort $prereq) \
	| sed 's/ /\t/g' \
	| sed '1d' \
	| awk 'BEGIN {FS="\t"; OFS="\t"} \
		{if (!$3) {print $0,"NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA", $2} \
		else {print $0}}' \
	| sort -nk 23
	} > $target'.build' \
	&& mv $target'.build' $target

#Solucion temporal a los casos cuando el query alinea en los extremos del subject
results/%.extended_mismatches.debug1.txt:	results/%.extended_mismatches.txt
	set -x
	mkdir -p `dirname "$target"`
	bin/correct-mismatches \
		$prereq \
	| sort -nk 22 \
	> $target'.build' \
	&& mv $target'.build' $target

results/%.extended_mismatches.txt:	results/%.noprocessing.txt	results/%.sequenceadded.txt
	set -x
	mkdir -p `dirname "$target"`
	#bin/sum-mismatches ${prereq} \
	{
	echo "#1_bta	2_pre-hsa	3_pident	4_length	5_mismatch	6_gapopen	7_qstart	8_qend	9_sstart	10_send 11_evalue	12_bitscore	13_QUERYLENGTH	14_SUBJECTLENGTH	15_QUERY5SEQ	16_QUERY3SEQ	17_SUBJECT5SEQ	18_SUBJECT3SEQ	19_COMPLETEQUERYSEQ	20_COMPLETESUBJECTSEQ	21_EXTENDEDMISMATCH	#22_TOTALMISMATCH" | tr '[:upper:]' '[:lower:]'
	cat $prereq \
	| grep -v ">" \
	| awk \
		'BEGIN{FS=OFS="\t"} \
		{print $0, $5+$6+$21}' \
	| awk '!seen[$1]++' \
	| sort -nk 22
	} > $target'.build' \
	&& mv $target'.build' $target

results/%.sequenceadded.txt:	results/%.forprocessing.txt
	set -x
	mkdir -p `dirname "$target"`
	{
	while read BLAST_RESULT
	do
	#Calculando valores de posicion para el QUERY, para posteriormente extraer del fasta
	QUERYID=`echo "$BLAST_RESULT" | cut -f1 `
	QUERYSTART=`echo "$BLAST_RESULT" | cut -f7 `
	QUERYEND=`echo "$BLAST_RESULT" | cut -f8 `
	QUERYLENGTH=`echo "$BLAST_RESULT" | cut -f13 `
	QUERY5LENGTH=$(( $QUERYSTART - 1 ))
	QUERY3LENGTH=$(( $QUERYLENGTH - $QUERYEND ))
	#Calculando valores de posicion para el SUBJECT, para posteriormente extraer del fasta de referencia
	SUBJECTID=`echo "$BLAST_RESULT" | cut -f2 `
	SUBJECTSTART=`echo "$BLAST_RESULT" | cut -f9 `
	SUBJECTEND=`echo "$BLAST_RESULT" | cut -f10 `
	SUBJECTLENGTH=`echo "$BLAST_RESULT" | cut -f14 `
	SUBJECT5LENGTH=$(( $SUBJECTSTART - 1 ))
	SUBJECT3LENGTH=$(( $SUBJECTLENGTH - $SUBJECTEND ))
	#Comparando longitudes de secuencias para ajustar tamaños y comparar posiciones equivalentes en el 5' y 3'
	if [ "$QUERY5LENGTH" -ne "$SUBJECT5LENGTH" ]; then
		MIN5LENGTH=`echo $QUERY5LENGTH $SUBJECT5LENGTH | tr " " "\n" | sort -n | head -n1`
	else
		MIN5LENGTH="1"
	fi
	if [ "$QUERY3LENGTH" -ne "$SUBJECT3LENGTH" ]; then
		MIN3LENGTH=`echo $QUERY3LENGTH $SUBJECT3LENGTH | tr " " "\n" | sort -n | head -n1`
	else
		MIN3LENGTH=$QUERY3LENGTH
	fi
	#Extrayendo secuencias
	if [ "$QUERYSTART" -eq 1 ] || [ "$SUBJECTSTART" -eq 1 ]; then
		QUERY5SEQ="NA"
	else
		QUERY5SEQ=`samtools faidx $QUERYFASTA "$QUERYID":"$(( $QUERYSTART - $MIN5LENGTH ))"-"$(( $QUERYSTART - 1 ))" | tail -n 1`
	fi
	if [ "$QUERYEND" -eq "$QUERYLENGTH" ] || [ "$SUBJECTEND" -eq "$SUBJECTLENGTH" ] ; then
		QUERY3SEQ="NA"
	else
		QUERY3SEQ=`samtools faidx $QUERYFASTA "$QUERYID":"$(( $QUERYEND + 1 ))"-"$(( $QUERYEND + $MIN3LENGTH ))" | tail -n 1`
	fi
	if [ "$QUERY5SEQ" = "NA" ]; then
		SUBJECT5SEQ="NA"
	else
		SUBJECT5SEQ=`samtools faidx $SUBJECTFASTA "$SUBJECTID":"$(( $SUBJECTSTART - $MIN5LENGTH ))"-"$(( $SUBJECTSTART - 1 ))" | tail -n 1`
	fi
	if [ "$QUERY3SEQ" = "NA" ]; then
		SUBJECT3SEQ="NA"
	else
		SUBJECT3SEQ=`samtools faidx $SUBJECTFASTA "$SUBJECTID":"$(( $SUBJECTEND + 1 ))"-"$(( $SUBJECTEND + $MIN3LENGTH))" | tail -n 1`
	fi
	#Se agrega un bloque para cambiar U por T, lo cual permite comparar con resultados de RNA
	QUERY5SEQ=`echo -n $QUERY5SEQ | tr "U" "T"`
	QUERY3SEQ=`echo -n $QUERY3SEQ | tr "U" "T"`
	SUBJECT5SEQ=`echo -n $SUBJECT5SEQ | tr "U" "T"`
	SUBJECT3SEQ=`echo -n $SUBJECT3SEQ | tr "U" "T"`
	COMPLETEQUERYSEQ="$QUERY5SEQ$QUERY3SEQ"
	COMPLETESUBJECTSEQ="$SUBJECT5SEQ$SUBJECT3SEQ"
	QUERYSEQ=`echo "$COMPLETEQUERYSEQ" | sed 's/./&\n/g'`
	SUBJECTSEQ=`echo "$COMPLETESUBJECTSEQ" | sed 's/./&\n/g'`
	EXTENDEDMISMATCH=`paste <(echo "$QUERYSEQ")  <(echo "$SUBJECTSEQ") | awk '$1 != $2 {print "MISMATCH"}' | grep -c "MISMATCH"`
	BLASTMISMATCH=`echo "$BLAST_RESULT" | cut -f5`
	GAPMISMATCH=`echo "$BLAST_RESULT" | cut -f6`
	#Calculo numero total de mismatches
	#TOTALMISMATCH=$(( $EXTENDEDMISMATCH + $BLASTMISMATCH + $GAPMISMATCH ))
	#echo "$BLAST_RESULT	$QUERY5SEQ	$QUERY3SEQ	$SUBJECT5SEQ	$SUBJECT3SEQ	$COMPLETEQUERYSEQ	$COMPLETESUBJECTSEQ	$EXTENDEDMISMATCH	$TOTALMISMATCH"
	echo "$BLAST_RESULT	$QUERY5SEQ	$QUERY3SEQ	$SUBJECT5SEQ	$SUBJECT3SEQ	$COMPLETEQUERYSEQ	$COMPLETESUBJECTSEQ	$EXTENDEDMISMATCH"
	done < $prereq
	} > $target'.build' \
	&& mv $target'.build' $target

results/%.noprocessing.txt: results/%.querylength.txt
	set -x
	mkdir -p `dirname "$target"`
        awk 'BEGIN {FS="\t"; OFS="\t"} $4 == $13 {print $0,"NA","NA","NA","NA", "NA", "NA", 0}' $prereq \
        | tr -s "\t" > $target'.build' \
        && mv $target'.build' $target

results/%.forprocessing.txt:	results/%.querylength.txt
	set -x
	mkdir -p `dirname "$target"`
	awk 'BEGIN {FS="\t"; OFS="\t"} $4 < $13 {print $0}' $prereq \
	> $target'.build' \
        && mv $target'.build' $target

results/%.querylength.txt: results/%.noheader.txt $QUERYFASTA results/%.subjectlength.txt
	set -x
	mkdir -p `dirname "$target"`
	{
	while read BLAST_RESULT
	do
	##		echo "estoy procesando.."
	##		echo "$BLAST_RESULT"
		MIRNAID=`echo "$BLAST_RESULT" | cut -f1 `
		QUERYSEQUENCE=`grep -A1 "^>$MIRNAID" $QUERYFASTA | tail -n 1`
		QUERYLENGTH=`echo -n $QUERYSEQUENCE | wc -c`
		SUBJECTID=`echo "$BLAST_RESULT" | cut -f2 `
		SUBJECTLENGTH=`grep ^$SUBJECTID results/$stem.subjectlength.txt | cut -f2`
		echo "$BLAST_RESULT	$QUERYLENGTH	$SUBJECTLENGTH"
	done < results/$stem.noheader.txt
	} > $target'.build' \
	&& mv $target'.build' $target

results/%.noheader.txt:	data/%.txt
	set -x
	mkdir -p `dirname "$target"`
	tail -n+2 $prereq > $target'.build' \
	&& mv $target'.build' $target

results/%.subjectlength.txt:	$SUBJECTFASTA
	infoseq \
		-name \
		-length \
		-only $prereq \
	| tr -s " " \
	| tr " " "\t" \
	> $target'.build' \
        && mv $target'.build' $target

# Quality Control
# ===============
#
# Here you should describe why you choose this qc.
#
qc:VQ:
	cd qc
	bin/targets | xargs mk

# Unit tests
# ==========
#
# Verify everything works correctly.
#
test	tests:QV:
	cd test
	rm -f tests.log
	./run_tests \
	|| less tests.log

# Clean up generated files
# ========================
#
clean:V:
	bin/targets | xargs rm -f
