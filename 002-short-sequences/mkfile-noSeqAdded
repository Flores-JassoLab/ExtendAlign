MKSHELL=/bin/bash

< config.mk
#AÃ±adiendo aquellas secuencias que no alinearon en blastn
results/%.final_mismatch.txt:	results/%.extended_mismatches.debug1.txt
	set -x
	mkdir -p `dirname "$target"`
	{
	echo "#1_bta	2_bta-length	3_pre-hsa	4_pident	5_length	6_mismatch	7_gapopen	8_qstart	9_qend	10_sstart	11_send	12_evalue	13_bitscore	14_QUERYLENGTH	15_SUBJECTLENGTH	16_QUERY5SEQ	17_QUERY3SEQ	18_SUBJECT5SEQ	19_SUBJECT3SEQ	20_COMPLETEQUERYSEQ	21_COMPLETESUBJECTSEQ	22_EXTENDEDMISMATCH	#23_TOTALMISMATCH" | tr '[:upper:]' '[:lower:]'
	join \
		-a 1 \
			<(awk '$0 ~ /^>/ {name=$0; next}; $0 !~ /^>/ {print name "\t" length($0)}' \
			$QUERYFASTA \
			| sort \
			| sed 's/^>//g' \
			| sed -e '1i\#1_bta\t2_bta-length') \
			<(sort $prereq) \
	| sed 's/ /\t/g' \
	| sed '1d' \
	| awk 'BEGIN {FS="\t"; OFS="\t"} \
		{if (!$3) {print $0,"NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA","NA", $2} \
		else {print $0}}' \
	| sort -nk 23
	} > $target'.build' \
	&& mv $target'.build' $target

#Solucion temporal a los casos cuando el query alinea en los extremos del subject
results/%.extended_mismatches.debug1.txt:	results/%.extended_mismatches.txt
	set -x
	mkdir -p `dirname "$target"`
	bin/correct-mismatches \
		$prereq \
	| sort -nk 22 \
	> $target'.build' \
	&& mv $target'.build' $target

results/%.extended_mismatches.txt:	results/%.noprocessing.txt	results/%.sequenceadded.txt
	set -x
	mkdir -p `dirname "$target"`
	#bin/sum-mismatches ${prereq} \
	{
	echo "#1_bta	2_pre-hsa	3_pident	4_length	5_mismatch	6_gapopen	7_qstart	8_qend	9_sstart	10_send 11_evalue	12_bitscore	13_QUERYLENGTH	14_SUBJECTLENGTH	15_QUERY5SEQ	16_QUERY3SEQ	17_SUBJECT5SEQ	18_SUBJECT3SEQ	19_COMPLETEQUERYSEQ	20_COMPLETESUBJECTSEQ	21_EXTENDEDMISMATCH	#22_TOTALMISMATCH" | tr '[:upper:]' '[:lower:]'
	cat $prereq \
	| grep -v ">" \
	| awk \
		'BEGIN{FS=OFS="\t"} \
		{print $0, $5+$6+$21}' \
	| awk '!seen[$1]++' \
	| sort -nk 22
	} > $target'.build' \
	&& mv $target'.build' $target

results/%.sequenceadded.txt:	results/%.forprocessing.txt
	set -x
	mkdir -p `dirname "$target"`
	bin/extend-alignment < $prereq
	> $target'.build' \
	&& mv $target'.build' $target

results/%.noprocessing.txt: results/%.querylength.txt
	set -x
	mkdir -p `dirname "$target"`
        awk 'BEGIN {FS="\t"; OFS="\t"} $4 == $13 {print $0,"NA","NA","NA","NA", "NA", "NA", 0}' $prereq \
        | tr -s "\t" > $target'.build' \
        && mv $target'.build' $target

results/%.forprocessing.txt:	results/%.querylength.txt
	set -x
	mkdir -p `dirname "$target"`
	awk 'BEGIN {FS="\t"; OFS="\t"} $4 < $13 {print $0}' $prereq \
	> $target'.build' \
        && mv $target'.build' $target

results/%.querylength.txt: results/%.noheader.txt $QUERYFASTA results/%.subjectlength.txt
	set -x
	mkdir -p `dirname "$target"`
	{
	while read BLAST_RESULT
	do
	##		echo "estoy procesando.."
	##		echo "$BLAST_RESULT"
		MIRNAID=`echo "$BLAST_RESULT" | cut -f1 `
		QUERYSEQUENCE=`grep -A1 "^>$MIRNAID" $QUERYFASTA | tail -n 1`
		QUERYLENGTH=`echo -n $QUERYSEQUENCE | wc -c`
		SUBJECTID=`echo "$BLAST_RESULT" | cut -f2 `
		SUBJECTLENGTH=`grep ^$SUBJECTID results/$stem.subjectlength.txt | cut -f2`
		echo "$BLAST_RESULT	$QUERYLENGTH	$SUBJECTLENGTH"
	done < results/$stem.noheader.txt
	} > $target'.build' \
	&& mv $target'.build' $target

results/%.noheader.txt:	data/%.txt
	set -x
	mkdir -p `dirname "$target"`
	tail -n+2 $prereq > $target'.build' \
	&& mv $target'.build' $target

results/%.subjectlength.txt:	$SUBJECTFASTA
	infoseq \
		-name \
		-length \
		-only $prereq \
	| tr -s " " \
	| tr " " "\t" \
	> $target'.build' \
        && mv $target'.build' $target

# Quality Control
# ===============
#
# Here you should describe why you choose this qc.
#
qc:VQ:
	cd qc
	bin/targets | xargs mk

# Unit tests
# ==========
#
# Verify everything works correctly.
#
test	tests:QV:
	cd test
	rm -f tests.log
	./run_tests \
	|| less tests.log

# Clean up generated files
# ========================
#
clean:V:
	bin/targets | xargs rm -f
